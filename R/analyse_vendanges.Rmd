---
title: "Analyse vendanges DADS"
author: "Thomas Vroylandt"
date: "20/11/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(here)
library(gganimate)

# Import
dads_postes <- read_rds(here("data/dads_filtre_05_15.rds"))
```

Intro sur qui compose la PCS au niveau métier, combien d'emploi (postes) cela représente + renvoi à la note méthodologique de fin.

691D : Ouvriers de la viticulture ou de l'arboriculture fruitière

## Deux types d'emplois

On cherche ici à séparer deux types d'emploi dans la PCS :

+ les emplois permanents : on prend les postes non annexes : ils représentent un peu moins de la moitié des emplois mais une forte majorité des jours travaillés ;
+ les emplois saisonniers : on prend les postes annexes. De fait, le constat est inversé.

On va se servir de cette différence dans l'analyse.

```{r diff_emploi}
# % des emplois
dads_postes %>% 
  group_by(annee, FILT) %>% 
  count() %>% 
  group_by(annee) %>% 
  mutate(part_n = n /sum(n)) %>% 
  ungroup()

# On construit des périodes d'emploi
seq_empl <- dads_postes %>% 
  group_by(annee, DATDEB, DATFIN, FILT) %>% 
  count() %>% 
  mutate(n = n * 12)

seq_empl_jour <- tibble(jour = seq(-30, 360, 1)) %>% 
  mutate(join = "1") %>% 
  full_join((seq_empl %>% 
               mutate(join = "1")),
            by = "join") %>% 
  mutate(ind_ok = case_when(jour >= DATDEB & jour <= DATFIN ~ "1",
                            TRUE ~ "0")) %>% 
  filter(ind_ok == "1") %>% 
  group_by(annee, jour, FILT) %>% 
  summarise(n = sum(n))  %>% 
  filter(jour > 0) %>% 
  group_by(annee) %>% 
  mutate(part_n = n / sum(n)) %>% 
  ungroup()

# % des jours travaillés
seq_empl_jour %>% 
  group_by(annee, FILT) %>% 
  summarise(sum(part_n))

# graph
gif_seq_empl_jour <- seq_empl_jour %>% 
  mutate(FILT = fct_recode(FILT,
                           "Annexe" = "2",
                           "Non annexe" = "1"),
         FILT = fct_relevel(FILT,
                            "Annexe", "Non annexe")) %>% 
  ggplot(aes(x = jour, y = part_n * 100, fill = FILT)) +
  geom_area(stat = "identity") +
  transition_time(annee) +
  labs(title = "{frame_time}")

# annee
dads_postes%>% 
  filter(FILT == "2" & annee != 2005) %>% 
  ggplot(aes(x = as.character(annee), y = DATDEB)) +
  geom_boxplot() +
  coord_flip()
```

## Analyse démographique

```{r demographie}
dads_demo <- dads_postes %>%
  mutate(AGE_TR = cut(AGE, breaks = c(0, 15, 19, 23, 27, 31, 35, 39, 
                                      43, 47, 51, 55, 59, 63, 67, 71, 150), 
                      include.lowest = TRUE, right = FALSE,
                      labels = c("00", "19", "23", "27", "31", "35", "39",
                                 "43", "47", "51", "55", "59", "63", "67", "71", "72"))) %>% 
  group_by(annee, SEXE, AGE_TR, FILT) %>% 
  count() %>% 
  mutate(n = n * 12) %>% 
  group_by(annee, FILT) %>% 
  mutate(part_n = n / sum(n) * 100,
         part_n = if_else(SEXE == "2", -part_n, part_n)) %>%
  filter(AGE_TR != "00" & !is.na(AGE_TR)) %>% 
  ungroup()

# Fusion
dads_demo %>% 
  ggplot(aes(x = AGE_TR, y = part_n, fill = SEXE)) +
  geom_bar(stat = "identity", position = "dodge", width = 2) +
  coord_flip() +
  facet_grid(rows = vars(annee), cols = vars(FILT))
```

## Analyse géographique

```{r}
dads_postes%>% 
  filter(FILT == "2" & DEPT %in% c("51", "33", "21", "69", "02", "13")) %>% 
  ggplot(aes(x = DEPT, y = DATDEB)) +
  geom_boxplot() +
  coord_flip()
```


## Analyse de la saisonnalité

```{r saisonnalite}
# On construit des périodes d'emploi
seq_empl <- dads_postes %>% 
  group_by(annee, DATDEB, DATFIN) %>% 
  count() %>% 
  mutate(n = n * 12)

seq_empl_jour <- tibble(jour = seq(-30, 360, 1)) %>% 
  mutate(join = "1") %>% 
  full_join((seq_empl %>% 
               mutate(join = "1")),
            by = "join") %>% 
  mutate(ind_ok = case_when(jour >= DATDEB & jour <= DATFIN ~ "1",
                            TRUE ~ "0")) %>% 
  filter(ind_ok == "1") %>% 
  group_by(annee, jour) %>% 
  summarise(n = sum(n))  %>% 
  filter(jour > 0) %>% 
  group_by(annee) %>% 
  mutate(part_n = n / sum(n)) %>% 
  ungroup()

# graph
seq_empl_jour %>% 
  ggplot(aes(x = jour, y = part_n * 100, color = as.character(annee))) +
  geom_line(lwd = 1)
```


> ## Méthodologie
>
> La déclaration annuelle de données sociales (DADS) est une formalité administrative obligatoire pour toute entreprise employant des salariés. Elle contient des informations relatives à l'établissement et au salarié.
> Ces données sont recueillies par l'Insee qui constitue des fichiers d'analyse. Le fichier utilisé ici est le fichier "postes" où chaque enregistrement correspond à un poste, c'est-à-dire à la consolidation des périodes de travail d'un salarié dans un même établissement.
>
> Un poste est catégorisé en fonction de plusieurs critères pour analyser si il re lève d'un "vrai" emploi ou d'un poste non annexe, par exemple saisonnier ou de très courte durée. Un poste est dit non-annexe si :
>
> + la rémunération nette est supérieure à 3 SMIC mensuels ;
> + ou le nombre d'heures salariées est supérieur à 120 et la durée de travail supérieure à 30 jours.
>
> Dans les autres cas, le poste est considéré comme annexe.
>
> ## Code et analyse
>
> L'ensemble de l'analyse et du code est disponible sur [github](https://github.com/tvroylandt/vendanges).
>
> Les remarques, commentaires et propositions sont les bienvenus : tvroylandt@gmail.com
>
